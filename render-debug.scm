(define (hue->rgb h)
  (let ((r (- (abs (- 3 (* h 6))) 1))
        (g (- 2 (abs (- 2 (* h 6)))))
        (b (- 2 (abs (- 4 (* h 6))))))
    (map
     (lambda (c)
       (exact/round (* 254 (/ (+ 2 c) 4))))
     (list r g b))))

(define (hue->color h #!optional (alpha 255))
  (match (hue->rgb h)
    ((r g b)
     (C r g b alpha))))

(define (qr->point grip q r)
  (cube->point grip (list q r)))

(define (cube-plane->edge renderer grip plane axis)
  (let ((ep (lambda (q r) (qr->point grip q r))))
    (let*-values (((a b) (viewport-point-range renderer))
                  ((av bv) (point-rect->axial-vec-range grip a b)))
      (match-let ((#(aq ar) av)
                  (#(bq br) bv))
        (case axis
          ;; x : (q . bq) . (q . br)
          ((0)
           (cons (ep plane ar)
                 (ep plane br)))
          ;; y : (aq . r) . (ar . r)
          ((1)
           (cons (ep aq plane)
                 (ep bq plane))))))))

(define (render-kd-hyperplanes-debug! renderer grip n t-kd)
  (let go ((depth 0)
           (t t-kd))
    (match t
      (#f #f)
      (($ kd-tree point left right)
       (let* ((axis (modulo depth 2))
              (plane (vector-ref point axis))
              (color (hue->color (/ depth (+ 1 n)))))
         (match (cube-plane->edge renderer grip plane axis)
           (((xa . ya) . (xb . yb))
            (set! (sdl2:render-draw-color renderer) color)
            (sdl2:render-draw-line! renderer xa ya xb yb))))
       (when (< depth n)
         (go (add1 depth) left)
         (go (add1 depth) right))))))

(define (render-color-order-debug! renderer n)
  (map
   (lambda (f)
     (let ((color (hue->color (/ f n)))
           (x-offset (* f 20)))
       (set! (sdl2:render-draw-color renderer) color)
       (sdl2:render-fill-rect! renderer (R (+ 100 x-offset) 100 20 20))))
   (iota n)))
